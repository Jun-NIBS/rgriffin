% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runQuery.R
\name{runGquery}
\alias{runGquery}
\title{Run a Griffin query from an interaction graph.}
\usage{
runGquery(query, return = c("strings", "files", "iterator", "BoolNet"),
  folder.name = NULL, network.name = NULL, allow.hypothesis = F,
  allow.additional.states = F, allow.additional.cycles = F,
  allow.ambiguity = F, block.steady.a.posteriori = T,
  divide.query.by.topology = F, divide.method = c("radial",
  "sequential"), value.divide.radius = 3, value.divide.range = "1,3",
  return.network.limit = NULL)
}
\arguments{
\item{query}{Griffin query}

\item{return}{"all" return all networks as strings
"files" save all networks as files in "folder.name/network.name-index.csv"
"iterator" returns rjava controller     
"BoolNet"  returns a BoolNet iterator}

\item{folder.name}{folder name to save networks, default date+time}

\item{network.name}{network name to save networks as files, default "net"}

\item{allow.hypothesis}{activate or deactivate hypothetical regulations}

\item{allow.additional.states}{allows networks with additional fixed-point attractors to those specified in the query}

\item{allow.additional.cycles}{allows networks with additional cyclic attractors to those specified in the query}

\item{allow.ambiguity}{allow ambiguous networks, if true ambiguous regulations may appear in the solutions}

\item{block.steady.a.posteriori}{use model checking and clause learning instead of enforceing fixed-point attractors in the query}

\item{divide.query.by.topology}{divide the query into multiple queries by query splitting methods}

\item{divide.method}{"radial": computes centres as regulation graphs with no hypotheses and explores adding combinations of 
        the hypothetical regulations, the number of simultaneous regulations equals the radius
"sequential": sets an interval for the exploration, regulation graphs are ennumerated in a lexicographic order}

\item{value.divide.radius}{(radial only) max number of simultaneous hypotheses used}

\item{value.divide.range}{(sequential only) constrain in the exploration of the graphs}

\item{return.network.limit}{maximum number of Boolean networks to return, if NULL there will be no limit}
}
\value{

}
\description{
This function takes a valid gquery created with create.gquery and add.gquery methods
and returns the set of boolean networks that satisfy the query.
}
\examples{
# Define the query
genes = c('a','b','c')
inter = data.frame(source=c('a','b','b','c','c'), 
                   target=c('b','b','c','b','c'), 
                   type=c('+','+','-','-','+'),
                   stringsAsFactors = F )
q = create.gquery.graph(inter, genes)
attr = data.frame(a=c(0,'*',0), 
                  b=c(0,1,0), 
                  c=c(0,0,1),
                  stringsAsFactors = F )
q = add.gquery.attractors(q, attr)
print( q )

# Run the query
nets = runGquery(q)
print( nets )

# Get BoolNet iterator
nets = runGquery(q, return="BoolNet")
nets
nextElem(nets)


}
