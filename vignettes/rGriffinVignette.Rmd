---
title: "rGriffin"
author: 
- name: Mariana E Martinez-Sanchez
- name: Stalin MuÃ±oz
- name: Miguel Carrillo
- name: Eugenio Azpeitia
- name: David Rosenblueth
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rGriffin}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction



Phenotype is the result of the interaction of multiple genes

Boolean syncrolous networks are a simplification, 
proposed by kaufman
nodes
interactions
state
attractors

Biological problem


We can approximate the interaction graph and the attractors
We are not sure of the functions

Does the solution exist?
Is there only one solution?

Using a simple file interface, griffin takes as inputs biologically meaningful constraints and turns them into a symbolic representation. Using a SAT engine, griffin explores the Boolean Network search space, finding all satisfying assignments that are compatible with the specified constraints

This allows to determine if the information is sufficient
Find the models that satisfy the restrictions

Incorporate multiple types of biological data with different levels of certanty.

Search for patterns in the families of possible networks

I



## Queries

We are not iterating all possible networks, but determining the networks that satisfy our conditions. 

If there are more restrictions we expect less networks. We recommend beggining with more stringent queries and then relaxing the restrictions.

The time that griffin will take depends on:

* Number of possible solutions
* The number of regulators of each node

### Create a query

All queries start with a topology that describes the nodes and its interactions. The function `create.gquery.graph()` takes a dataframe with columns for: source node, target node, and type of interaction. It also takes a vector with the node names.

Depending on the sign the interactions can **positive** or **negative**. If in every condition the regulation will have the same sign the interaction is **ambiguous**. However, if you are not sure if the regulation is positive or negative in all contexts you can say that the interaction is **ambiguous**.  Depending on the degree of confidence in the existence of the interaction, the interactions can be: **mandatory** if you are sure the interaction will happen or **optional** if you suspect the interaction exists but you are not sure.

The valid types of interctions are: 

* false: Contradiction 
* MA: Mandatory, ambiguous 
* MPU (or +): Mandatory, positive, unambiguous 
* MPPA: Mandatory, positive, possibly ambiguous 
* MNU (or -): Mandatory, negative, unambiguous 
* MNPA: Mandatory, negative, possibly ambiguous 
* MUSU: Mandatory, unknown sign, unambiguous 
* MUSPA: Mandatory, unknown sign, possibly ambiguous 
* NR: No regulation 
* OA: Optional, ambiguous 
* OPU: Optional, positive, unambiguous 
* OPPA: Optional, positive, possibly ambiguous 
* ONU: Optional, negative, unambiguous 
* ONPA: Optional, negative, possibly ambiguous 
* OUSU: Optional, unknown sign, unambiguous 
* true: Tautology

For example, suppose a network where:

* **a** activates **b**
* **b** and **c** inhibit each other
* **b** and **c** __may__ have a positive self-regulatory loops.

We can codify this information as:

```{r, echo=TRUE}
genes = c('a','b','c')
inter = data.frame(source=c('a','b','b','c','c'), 
                  target=c('b','b','c','b','c'), 
                  type=c('+','OPU','-','-','OPU'),
                    stringsAsFactors = F )
inter
```

We then create the query `q`. This creates an instance of the class query in the JVM. 

```{r, echo=TRUE}
q = create.gquery.graph(inter, genes)
q
```

If you want to see the query use the `print` method.

```{r, echo=TRUE}
print(q)
```


### Add restrictions to the query

It is possible to add more restrictions to the query. It is important to remember that 
if there are more restrictions we expect less networks. 

For example, suppose that we have some information about the expected cell types. We can add this restrictions as attractors.

For example, suppose that we know that the attractors are:

* Only express __b__ => c(0,1,0)
* Only express __c__ => c(0,0,1)

We can also add partial attractors where we lack information

* Do not express __a__ or __c__ but we have NO information or b => c(0,'*',0)

We codify this information as:

```{r, echo=TRUE}
attr = data.frame(a=c(0,'*',0), 
                 b=c(0,1,0), 
                 c=c(0,0,1),
                 stringsAsFactors = F )
```

We can add this information to the query with the `add.gquery.attractors()` function:

```{r, echo=TRUE}
q = add.gquery.attractors(q, attr)
```

You can add aditional restrictions like:

* `add.gquery.cycle()`	Add target cycle 
* `add.gquery.mutant()`	Add mutant with attractors 
* `add.gquery.prohibited.attractors()`	Add prohibited attractors
* `add.gquery.transition()`	Add a transition between two succesive states
* `add.gquery.trapspace()`	Add a trapspace


### Run the query

Once you have created the query with `run.gquery()`. This function will return all the networks that satisfy the restrictions

```{r, echo=TRUE}
nets = run.gquery(q)
print(nets)
```

The function `run.gquery()` includes multiple options that can be seen in the documentation. Some of the most important are:

* `allow.hypothesis`	activate or deactivate hypothetical regulations
* `allow.additional.states`	allows networks with additional fixed-point attractors to those specified in the query
* `allow.additional.cycles`	allows networks with additional cyclic attractors to those specified in the query
* `return.network.limit` limit the maximum number of networks that the query will return



## Connect to other packages

### BoolNet

The R package includes various functions to import and export data to `BoolNet`.

It is possible to obtain the topology of a `BooleanNetwork` object using `get.net.topology()`. This function determines the sign of each regulation as positive '+', negative '-' or ambiguous 'MA'. All regulations between nodes are considered mandatory. The function can also detect Non-functional regulations 'NR'.

```{r, echo=TRUE}
library(BoolNet)
data("cellcycle")
topology <- get.net.topology(cellcycle)
topology
```

It is also possible to convert an `AttractorInfo` object into a data.frame using `attractor2dataframe`.

```{r, echo=TRUE}
cc.attr <- getAttractors(cellcycle)
cycle <- attractor2dataframe(cc.attr)
cycle <- cycle[cellcycle$genes] #remove info columns
cycle
```

Using this functions, it is possible to create a query that corresponds to a Boolean network. As we expect a cyclic attractor we will use `add.gquery.cycle()`.

```{r, echo=TRUE}
q <- create.gquery.graph(topology, cellcycle$genes)
q <- add.gquery.cycle(q, cycle)
```

It is also possible to export the networks generated by `run.gquery()` directly to `BoolNet` with the option `return = "BoolNet"`. This option generates an iterator object, that returns the `BooleanNetwork` objects one by one using the function `iterators::nextElem()`. 

For example, if we use the three node example network:

```{r, include = FALSE}
genes = c('a','b','c')
inter = data.frame(source=c('a','b','b','c','c'), 
                  target=c('b','b','c','b','c'), 
                  type=c('+','+','-','-','+'),
                    stringsAsFactors = F )
q = create.gquery.graph(inter, genes)

attr = data.frame(a=c(0,'*',0), 
                 b=c(0,1,0), 
                 c=c(0,0,1),
                 stringsAsFactors = F )
q = add.gquery.attractors(q, attr)
```

```{r, echo=TRUE}
nets = run.gquery(q,return = "BoolNet")
iterators::nextElem(nets)
```

If there are no more available networks the `nextElem()` method will rise an error: `Error in obj$nextElem() : StopIteration`.


### Other

It is possible to plot the network topology dataframe with the R package `igraph`. This dataframe can also be used to import and export the network topology to other resources like the python library `networkx` or to the software `Cytoscape`.

It is possible to export the network functions as an SBML file using the `BoolNet` function `toSBML()`.





## References




```{r, echo=TRUE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
